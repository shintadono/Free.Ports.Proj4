/////////////////////////////////////////////////////////////////////////////
// geodesic.cs
// Geodesic routines
/////////////////////////////////////////////////////////////////////////////
//
// This is a C# portation of an implementation in C of the geodesic algorithms
// described in: C. F. F. Karney, Algorithms for geodesics, J. Geodesy 87, 43--55 (2013)
//   DOI: 10.1007/s00190-012-0578-z
//   addenda: http://geographiclib.sourceforge.net/geod-addenda.html.
//
// The principal advantages of these algorithms over previous ones (e.g.,
// Vincenty, 1975) are
// - accurate to round off for |f|<1/50;
// - the solution of the inverse problem is always found;
// - differential and integral properties of geodesics are computed.
//
// The shortest path between two points on the ellipsoid at (lat1,
// lon1) and (lat2, lon2) is called the geodesic. Its length is
// s12 and the geodesic from point 1 to point 2 has forward azimuths
// azi1 and azi2 at the two end points.
//
// Traditionally two geodesic problems are considered:
// - the direct problem -- given lat1, lon1, s12, and azi1, determine lat2,
//   lon2, and azi2. This is solved by the function geod_direct().
// - the inverse problem -- given lat1, lon1, and lat2, lon2, determine s12,
//   azi1, and azi2. This is solved by the function geod_inverse().
//
// The ellipsoid is specified by its equatorial radius a (typically in
// meters) and flattening f. The routines are accurate to round off with
// double precision arithmetic provided that |f|<1/50; for the WGS84 ellipsoid,
// the errors are less than 15 nanometers. (Reasonably accurate results
// are obtained for |f|<1/5.) For a prolate ellipsoid, specify f<0.
//
// The routines also calculate several other quantities of interest
// - S12 is the area between the geodesic from point 1 to point 2 and the
//   equator; i.e., it is the area, measured counter-clockwise, of the
//   quadrilateral with corners (lat1, lon1), (0, lon1), (0, lon2),
//   and (lat2, lon2).
// - m12, the reduced length of the geodesic is defined such that if
//   the initial azimuth is perturbed by dazi1 (radians) then the
//   second point is displaced by m12 dazi1 in the direction
//   perpendicular to the geodesic. On a curved surface the reduced
//   length obeys a symmetry relation, m12+m21=0. On a flat
//   surface, we have m12=s12.
// - M12 and M21 are geodesic scales. If two geodesics are
//   parallel at point 1 and separated by a small distance dt, then
//   they are separated by a distance M12 dt at point 2. M21
//   is defined similarly (with the geodesics being parallel to one
//   another at point 2). On a flat surface, we have M12=M21=1.
// - a12 is the arc length on the auxiliary sphere. This is a
//   construct for converting the problem to one in spherical
//   trigonometry. a12 is measured in degrees. The spherical arc
//   length from one equator crossing to the next is always 180deg.
//
// If points 1, 2, and 3 lie on a single geodesic, then the following
// addition rules hold:
// - s13=s12+s23
// - a13=a12+a23
// - S13=S12+S23
// - m13=m12*M23+m23*M21
// - M13=M12*M23-(1-M12*M21)*m23/m12
// - M31=M32*M21-(1-M23*M32)*m12/m23
//
// The shortest distance returned by the solution of the inverse problem is
// (obviously) uniquely defined.  However, in a few special cases there are
// multiple azimuths which yield the same shortest distance. Here is a
// catalog of those cases:
// - lat1=-lat2 (with neither point at a pole). If azi1=azi2,
//   the geodesic is unique. Otherwise there are two geodesics
//   and the second one is obtained by setting [azi1, azi2]=[azi2, azi1],
//   [M12, M21]=[M21, M12], S12=-S12. (This occurs when the longitude difference
//   is near +/-180deg for oblate ellipsoids.)
// - lon2=lon1+/-180deg (with neither point at a pole).
//   If azi1=0deg or +/-180deg, the geodesic is unique.
//   Otherwise there are two geodesics and the second one is obtained by
//   setting [azi1, azi2]=[-azi1, -azi2], S12=-S12. (This occurs when lat2 is
//   near -lat1 for prolate ellipsoids.)
// - Points 1 and 2 at opposite poles. There are infinitely many geodesics which
//   can be generated by setting [azi1, azi2]=[azi1, azi2]+[d, -d],
//   for arbitrary d. (For spheres, this prescription applies when points 1 and
//   2 are antipodal.)
// - s12=0 (coincident points). There are infinitely many geodesics which can be
//   generated by setting [azi1, azi2]=[azi1, azi2]+[d, d], for arbitrary d.
//
// These routines are a simple transcription of the corresponding C++ classes
// in GeographicLib (http://geographiclib.sourceforge.net). The "class data" is 
// represented by the structs geod_geodesic, geod_geodesicline,
// geod_polygon and pointers to these objects are passed as initial arguments
// to the member functions. Most of the internal comments have been retained.
// However, in the process of transcription some documentation has been lost
// and the documentation for the C++ classes, GeographicLib::Geodesic,
// GeographicLib::GeodesicLine, and GeographicLib::PolygonAreaT, should be
// consulted. The C++ code remains the "reference implementation". Think
// twice about restructuring the internals of the C code since this may make
// porting fixes from the C++ code more difficult.
//
// Copyright (c) Charles Karney (2012-2016) <charles@karney.com> and licensed
// under the MIT/X11 License. For more information, see
// http://geographiclib.sourceforge.net/
//
// This library was distributed with GeographicLib 1.46.
/////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;

namespace Free.Ports.Proj4.Geodesic
{
	public abstract class geodesic
	{
		#region Version
		/// <summary>
		/// The major version of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_MAJOR = 1;

		/// <summary>
		/// The minor version of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_MINOR = 46;

		/// <summary>
		/// The patch level of the geodesic library. (This tracks the version of GeographicLib.)
		/// </summary>
		public const int GEODESIC_VERSION_PATCH = 1;

		/// <summary>
		/// Pack the version components into a single integer. Users should not rely on
		/// this particular packing of the components of the version number; see the
		/// documentation for GEODESIC_VERSION, below.
		/// </summary>
		/// <param name="a">The major version number.</param>
		/// <param name="b">The minor version number.</param>
		/// <param name="c">The patch level.</param>
		/// <returns>The packed version.</returns>
		public static int GEODESIC_VERSION_NUM(int a, int b, int c) { return (((a * 10000 + b) * 100) + c); }

		/// <summary>
		/// The version of the geodesic library as a single integer, packed as MMmmmmpp
		/// where MM is the major version, mmmm is the minor version, and pp is the
		/// patch level.
		/// </summary>
		/// <remarks>
		/// Users should not rely on this particular packing of the components of 
		/// the version number. Instead they should use a test such as
		/// <code>
		/// if(GEODESIC_VERSION>=GEODESIC_VERSION_NUM(1, 40, 0))
		/// </code>
		/// </remarks>
		public static readonly int GEODESIC_VERSION = GEODESIC_VERSION_NUM(GEODESIC_VERSION_MAJOR, GEODESIC_VERSION_MINOR, GEODESIC_VERSION_PATCH);
		#endregion

		#region Const and static readonly
		protected const int GEOGRAPHICLIB_GEODESIC_ORDER = 6;
		protected const int nA1 = GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC1 = GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC1p = GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nA2 = GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nC2 = GEOGRAPHICLIB_GEODESIC_ORDER;
		protected const int nA3 = GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nA3x=nA3;
		protected const int nC3 = GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nC3x=((nC3*(nC3-1))/2);
		protected const int nC4 = GEOGRAPHICLIB_GEODESIC_ORDER;
		//protected const int nC4x=((nC4*(nC4+1))/2);
		protected const int nC = (GEOGRAPHICLIB_GEODESIC_ORDER + 1);

		protected const int digits = 53; // Number of bits in the mantissa of a double
		protected const double epsilon = 2.2204460492503131e-16; // Distance between 1 and the next number storeable in a double (1.0+epsilon!=1.0)
		protected const double realmin = double.Epsilon; // The smallest number bigger than zero
		protected const double pi = Math.PI;
		protected const int maxit1 = 20;
		protected const int maxit2 = maxit1 + digits + 10;

		protected static readonly double tiny = Math.Sqrt(realmin);
		protected const double tol0 = epsilon;

		// Increase multiplier in definition of tol1 from 100 to 200 to fix inverse case
		// 52.784459512564 0 -52.784459512563990912 179.634407464943777557
		// which otherwise failed for Visual Studio 10 (Release and Debug)
		protected const double tol1 = 200 * tol0;
		protected static readonly double tol2 = Math.Sqrt(tol0);

		// Check on bisection interval.
		protected static readonly double tolb = tol0 * tol2;
		protected static readonly double xthresh = 1000 * tol2;

		protected const double degree = pi / 180;

		protected static readonly double NaN = double.NaN;
		#endregion

		protected static double sq(double x) { return x * x; }

		protected static double log1px(double x)
		{
			double y = 1 + x;
			double z = y - 1;

			// Here's the explanation for this magic: y = 1 + z, exactly, and z
			// approx x, thus log(y)/z (which is nearly constant near z = 0) returns
			// a good approximation to the true log(1 + x)/x. The multiplication x *
			// (log(y)/z) introduces little additional error.
			return z == 0 ? x : x * Math.Log(y) / z;
		}

		protected static double atanhx(double x)
		{
			double y = Math.Abs(x); // Enforce odd parity
			y = log1px(2 * y / (1 - y)) / 2;
			return x < 0 ? -y : y;
		}

		protected static double copysignx(double x, double y)
		{
			return Math.Abs(x) * (y < 0 || (y == 0 && 1 / y < 0) ? -1 : 1);
		}

		protected static double hypotx(double x, double y) { return Math.Sqrt(x * x + y * y); }

		protected static double cbrtx(double x)
		{
			double y = Math.Pow(Math.Abs(x), 1.0 / 3); // Return the real cube root
			return x < 0 ? -y : y;
		}

		protected static double sumx(double u, double v, out double t)
		{
			double s = u + v;
			double up = s - v;
			double vpp = s - up;

			up -= u;
			vpp -= v;
			t = -(up + vpp);

			// error-free sum:
			// u + v =       s      + t
			//       = round(u + v) + t
			return s;
		}

		protected static double polyval(int N, double[] p, double x)
		{
			double y = 0;
			for (int i = 0; i <= N; i++) y = y * x + p[i];
			return y;
		}

		protected static double polyval(int N, double[] p, int offset, double x)
		{
			double y = 0;
			for (int i = 0; i <= N; i++) y = y * x + p[i + offset];
			return y;
		}

		// mimic C++ std::min and std::max
		protected static double minx(double a, double b) { return b < a ? b : a; }

		protected static double maxx(double a, double b) { return a < b ? b : a; }

		protected static void swapx(ref double x, ref double y) { double t = x; x = y; y = t; }

		protected static void norm2(ref double sinx, ref double cosx)
		{
			double r = hypotx(sinx, cosx);
			sinx /= r;
			cosx /= r;
		}

		protected static double AngNormalize(double x)
		{
			x = x % 360.0;
			return x < -180 ? x + 360 : (x < 180 ? x : x - 360);
		}

		protected static double LatFix(double x) { return Math.Abs(x) > 90 ? double.NaN : x; }

		protected static double AngDiff(double x, double y, out double e)
		{
			double t, d = -AngNormalize(sumx(AngNormalize(x), AngNormalize(-y), out t));
			// Here y - x = d - t (mod 360), exactly, where d is in (-180,180] and
			// abs(t) <= eps (eps = 2^-45 for doubles).  The only case where the
			// addition of t takes the result outside the range (-180,180] is d = 180
			// and t < 0.  The case, d = -180 + eps, t = eps, can't happen, since
			// sum would have returned the exact result in such a case (i.e., given t
			// = 0).
			return sumx(d == 180 && t < 0 ? -180 : d, -t, out e);
		}

		protected static double AngRound(double x)
		{
			const double z = 1.0 / 16;
			if (x == 0) return 0;
			double y = Math.Abs(x);

			// The compiler mustn't "simplify" z - (z - y) to y
			y = y < z ? z - (z - y) : y;
			return x < 0 ? -y : y;
		}

		protected static void sincosdx(double x, out double sinx, out double cosx)
		{
			// In order to minimize round-off errors, this function exactly reduces
			// the argument to the range [-45, 45] before converting it to radians.
			double r = x % 360;
			int q = (int)Math.Floor(r / 90 + 0.5);
			r -= 90 * q;
			// now abs(r) <= 45
			r *= degree;
			// Possibly could call the gnu extension sincos
			double s = Math.Sin(r), c = Math.Cos(r);
			switch ((uint)q & 3U)
			{
				case 0U: sinx = s; cosx = c; break;
				case 1U: sinx = c; cosx = 0 - s; break;
				case 2U: sinx = 0 - s; cosx = 0 - c; break;
				default: sinx = 0 - c; cosx = s; break; // case 3U
			}
		}

		protected static double atan2dx(double y, double x)
		{
			// In order to minimize round-off errors, this function rearranges the
			// arguments so that result of atan2 is in the range [-pi/4, pi/4] before
			// converting it to degrees and mapping the result to the correct
			// quadrant.
			int q = 0;
			if (Math.Abs(y) > Math.Abs(x)) { swapx(ref x, ref y); q = 2; }
			if (x < 0) { x = -x; ++q; }
			// here x >= 0 and x >= abs(y), so angle is in [-pi/4, pi/4]
			double ang = Math.Atan2(y, x) / degree;
			switch (q)
			{
				// Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that
				// atan2d will not be called with y = -0.  If need be, include
				//
				//   case 0: ang = 0 + ang; break;
				case 1: ang = (y > 0 ? 180 : -180) - ang; break;
				case 2: ang = 90 - ang; break;
				case 3: ang = -90 + ang; break;
			}
			return ang;
		}

		protected static double SinCosSeries(bool sinp, double sinx, double cosx, double[] c, int n)
		{
			// Evaluate
			// y=sinp?sum(c[i]*sin( 2*i   *x), i, 1, n):
			//        sum(c[i]*cos((2*i+1)*x), i, 0, n-1)
			// using Clenshaw summation. N.B. c[0] is unused for sin series
			// Approx operation count=(n+5) mult and (2*n+2) add
			int i = (n + (sinp ? 0 : 1)); // Point to one beyond last element
			double ar = 2 * (cosx - sinx) * (cosx + sinx); // 2*cos(2*x)
			double y0 = ((n & 1) != 0) ? c[--i] : 0, y1 = 0; // accumulators for sum

			// Now n is even
			n /= 2;
			while (n-- != 0)
			{
				// Unroll loop x 2, so accumulators return to their original role
				y1 = ar * y0 - y1 + c[--i];
				y0 = ar * y1 - y0 + c[--i];
			}
			return sinp ?
				2 * sinx * cosx * y0 : // sin(2*x)*y0
				cosx * (y0 - y1); // cos(x)*(y0-y1)
		}
	}
}
